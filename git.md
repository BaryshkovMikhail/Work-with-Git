# Получение версии

git -- version

## Подпись

git config --global user.name "Emma Paris"

## Почта

git config --global user.email "<eparis@atlassian.com>"

## Проверк настроек

git config --global --list

## Задайте правильный формат строк

- Если у вас macOS или Linux, последовательно выполните две команды:
git config --global core.autocrlf input
git config --global core.autocrlf true
- Если у вас Windows, то выполните последовательно эти команды:
git config --global core.safecrlf warn
git config --global core.quotepath off
- Дальше общая для всех операционных систем команда, которая позволит
git config --global core.safecrlf warn

## Задайте общепринятое название основной ветки в репозитории в Git — main

git config --global init.defaultBranch main

## Git даст подробную подсказку по всем доступным командам, если выполнить команду

git help -g

## Git даст подсказку по конкретной команде, если ввести в терминале

git help команда

Чтобы выйти из справки, нажмите Escape → наберите :wq → нажмите Enter

## Чтобы прицепить Git к папке — создать локальный репозиторий — нужно выполнить команду

git init

## Чтобы проверить текущее состояние репозитория, введите в терминале команду

git status

## Чтобы добавить файл README.md в отслеживаемые, выполните в терминале команду

- git add + имя файла git add README.md
- Можно добавить в отслеживаемые сразу много файлов. Тогда нужно воспользоваться
сокращением и написать git add -A.
В коммит попадут все файлы из текущей папки, которые изменились с последнего коммита

## Что изменилось в проекте с последнего снимка выполните команду

- Добавить кмментарий
    git commit -m "add README" //В кавычках принято писать о том, то изменилось в проекте с последнего снимка.
- Исправьте подпись последнего коммита. Выполните команду
    git commit --amend -m "error"
- Поместите файл новый файл в последний коммит — снова используем команду
    git commit --amend -m "комментарий".
Теперь в последнем коммите хранится не только последняя версия файла "старый", но и новый файл "новый"
- Добравить файл в отслеживаемые и сразу закоментировать
    git commit -a -m "комментарий"

## Просмотр истории по проекту

- Выполните команду
    git log --oneline
- Чтобы посмотреть всю информацию о коммите, выполните команду
    git log без флага.
-Просматривать историю любой ветки
    git log имя-ветки --graph --oneline

## Переменщение по истории проекта

1. Выведите историю проекта через команду
   git log
2. Найдите хеш прошлого коммита, к которому хотите вернуться. Достаточно первых 7 символов
3. Переключитесь на нужный коммит с помощью команды
   git checkout хеш коммита
4. Вернуться к последнему коммиту можно командой
   git checkout -

## Генерация нового SSH-ключа

- выполните команду ssh-keygen
- Терминал спросит, куда сохранить файл с ключом и предложит дважды ввести пароль для этого ключа. На этом этапе советуем оставить все настройки по умолчанию. Просто нажмите несколько раз Enter
- Найдите в терминале строчку Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. Здесь важен путь, по которому сохранился ключ. Скопируйте окончание пути, начиная с /.ssh/
- Выполните команду cat ~/.ssh/id_rsa.pub, где после волнистой линии вставьте путь до вашего файла, который вы только что скопировали.
- На экране появится длинный набор символов, строка будет начинаться с ssh-rsa. Скопируйте весь этот набор символов — это и есть SSH-ключ
- Осталось добавить его в ваш профиль на GitHub. В браузере перейдите по [Добавление ключа](https://github.com/settings/keys)
- Нажмите кнопку New SSH key
- В поле Title введите название для ключа. Оно может быть абсолютно любым. В большое поле ниже вставьте длинный набор символов, который только, что скопировали из терминала. Нажмите кнопку Add SSH key

## Связь локального и удаленного репозитория

- Проверка удаленного репозитория
   git remote -v
- Создайте связь между локальным и удалёнными репозиториями. Выполните команду
   git remote add origin ссылка на папку удалённого репозитория
- Если нам когда-нибудь потребуется удалить связь, то можно использовать команду
   git remote remove origin
или какое-то другое название связи, которая больше не нужна.После этого список связей снова будет пуст.
- Чтобы отправить что-то в удалённый репозиторий, нужно воспользоваться командой
   git push -u origin main
- Скопировтаь удаленный репозиторий. Открыть новую папку. Ввести команду:
   git clone и вставьте только что скопированную ссылку

## Переход в другой проект

cd и имя папки

## Спиоск веток в проекте и их созданеи

- git branch
- git branch имя ветки
- git checkout и указать имя ветки // переключение в другу ветку
- git checkout -b имя ветки // создание и переход в эту ветку

## Слияние веток в Git

1. Переключитесь обратно основную ветку ветку, выполнив команду
   git checkout основная ветка
2. Чтобы слить ветку, нужно написать
   git merge имя ветки
3. Можно убедиться, что файл изменился. Если вы откройте его в VS Code, то увидите, что там появилась дата. Обновите проект на GitHub. Выполните команду git push. В этот раз можно не писать -u origin main. Это дополнение нужно только первый раз, когда отправляете новую ветку в GitHub. Git уже знает, что и куда отправлять

## Для обновления командного проекта на GitHub нужно использовать команду

git pull

## Чтобы переключаться к предыдущему состоянию проекта, используйте команду

git checkout хеш коммита

## Посмотреть всю историю проекта можно через команду

git log --oneline --all

## Чтобы отменить коммит в удалённом репозитории, нужно использовать команду

git revert хеш коммита для отмены

## Настроить .gitignore можно для папки и файла с помощью команды

git rm --cached имя-файла

## Перед каждым коммитом необходимо проиндексировать файлы, которые будут закоммичены

git add //Это можно сделать с помощью:
git commit -m "some useful comment here"  //либо добавив ключ:
git commit -v — добавить в комментарий коммита diff
git config --global core.editor — изменить редактор текста коммита

## Последний коммит в ветке обозначается как HEAD. Это сделано для упрощенного доступа к нему

git checkout имя файла //До выполнения индексации:
git reset HEAD имя файла //После индексации:
git revert HEAD --no-edit  //Откат изменений коммита осуществляется с помощью revert:
git log  //Вместо HEAD можно указать любой id коммита из истории. Просмотр истории:
git log --oneline   в одну строку
git show  // показать изменения
git diff что будет внесено
git commit --amerd // редактировать commit
git reset --soft хеш в придуший commit
git reset --hard хеш в придуший commit
git branch -v // пазать ветки

## Просмотр изменений

Если результат работы команды git status недостаточно информативен и хочется знать, что конкретно поменялось, можно использовать команды:
git diff — показывает что изменили, но пока не проиндексировали
git diff --staged и git diff --cached — сравнивает проиндексированные изменения с последним коммитом
git difftool — позволяет использовать графическую утилиту

## Создание веток

git checkout -b имя_ветки

## Слияние веток

git checkout -b имя_ветки
git checkout master
git merge develop

git checkout -b dev // создание новой ветки

## Клонировать репозиторий с сервера можно с помощью команды

git clone <https://github.com/netology-code/sysadm-homeworks.git>

Просмотр удаленных репозиториев:

git remote
git remote show origin // Репозиторий будет помещен в директорию ./имя_репозитория

## Добавление удаленного репозитория

git remote add origin <https://github.com/netology-code/sysadm-homeworks.git>
Отправка изменения в удаленный репозиторий:
git push origin master
Для того чтобы скачать себе последние изменения из репозитория:
git pull

## Удаление файлов

Чтобы удалить файл из Git, недостаточно просто удалить его из рабочего каталога. Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции Changes not staged for commit (изменённые, но не проиндексированные) вывода команды git status:
rm PROJECTS.md
git status
...
Changes not staged for commit:
...
deleted: PROJECTS.md

Надо воспользоваться git rm, чтобы удаление файла попало в индекс:
git rm PROJECTS.md
rm 'PROJECTS.md'
git status
...
Changes to be committed:
...
deleted: PROJECTS.md

git rm -f readme — удалить файл, если он уже проиндексирован
git rm --cached readme — оставить файл на жёстком диске, но перестать отслеживать
git rm log/\*.log — возможность использовать шаблоны

## Перемещение файлов

Для перемещения файлов также необходимо сообщить об этом Git:
git mv README.md README
git status
...
Changes to be committed:
...
renamed: README.md -> README

Git mv можно заменить такой, более длинной, последовательностью команд:
mv README.md README
git rm README.md
git add README
Единственное отличие в том, что mv — одна команда вместо трёх. Это функция для удобства. Важно, что вы можете использовать любой удобный способ для переименования файла, а затем воспользоваться командами add/rm перед коммитом

## Просмотр истории коммитов

Опции git log
--shortstat — отображает только строку с количеством изменений/вставок/удалений для команды --stat
--name-only — показывает список изменённых файлов после информации о коммите
--name-status — показывает список файлов, которые добавлены/изменены/удалены
--abbrev-commit — показывает только несколько символов чек-суммы SHA-1 вместо всех 40
--relative-date — отображает дату в относительном формате
--graph — отображает графы с ветвлениями
--pretty — альтернативный формат: oneline, short, full, fuller и format (с помощью последней можно указать свой формат)
--oneline — сокращение для одновременного использования опций --pretty=oneline--abbrev-commit
-(n) — показывает только последние n коммитов
--since, --after — показывает только те коммиты, которые были сделаны после указанной даты (например, "2008-01-15"), или же относительную дату, например "2 years 1 day 3 minutes ago"
--until, --before — показывает только те коммиты, которые были сделаны до указанной даты
--committer — показывает только те коммиты, в которых запись committer совпадает с указанной строкой
--grep — показывает только коммиты, сообщение которых содержит указанную строку
-S — показывает только коммиты, в которых изменение в коде повлекло за собой добавление или удаление указанной строки
--no-merges — не отображать коммиты слияния (мержа)

Основная команда для просмотра истории:
$ git log
У команды git log есть очень большое количество опций для поиска коммитов по разным критериям. Рассмотрим наиболее популярные из них

Полезным аргументом является --patch, который показывает разницу (выводит патч), внесённую в каждый коммит:
$ git log --patch -1 (или git log -p -1)

Опция --stat отображает аналогичную информацию, но содержит
разницу для каждой записи:
$ git log --stat -2
Опция --stat печатает под каждым из коммитов список и количество изменённых файлов, а также количество строк, которое было добавлено и удалено в каждом из файлов. В конце можно увидеть суммарную таблицу изменений

Форматированный вывод
Следующая полезная опция — --pretty. Эта опция меняет формат вывода:

git log --pretty=oneline (или short, full, fuller)

Интересная опция — format, она позволяет указать формат для вывода данных:

git log --pretty=format:"%h - %an, %ar : %s"

Опции форматирования
%H — хеш коммита
%h — сокращённый хеш коммита
%T — хеш дерева
%t — сокращённый хеш дерева
%P — хеш родителей
%p — сокращённый хеш родителей
%an — имя автора
%ae — электронная почта автора
%ad — дата автора (формат даты можно задать опцией --date=option)
%ar — относительная дата автора
%cn — имя коммитера
%ce — электронная почта коммитера
%cd — дата коммитера
%cr — относительная дата коммитера
%s — описание коммита

Посмотреть данные коммита, зная его хеш:
git show

## Amend

В результате выполнения команд получится единый коммит — второй коммит заменит результаты первого:
git commit -m 'initial commit'
git add forgotten_file
git commit --amend

Мы можем попробовать найти старый коммит при помощиgit show и git log, так как на самом деле старый коммит также остался в истории

Если случайно выполнили git add *, то git status подскажет, как
отменить индексацию:
git add*
git status

```text
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)

modified: CONTRIBUTING.md
```

## Просмотр удалённых репозиториев

Посмотреть их список: git remote. После клонирования как минимум один origin — имя по умолчанию. Его Git даёт серверу, с которого производилось клонирование. Ключ -v для более подробного вывода:
git clone <git@github.com>:snapcart/repo.git
cd repo
git remote
git remote -v

Чтобы добавить удалённый репозиторийи присвоить ему имя (shortname), просто выполните команду git remote add <shortname> <url>:
$ git remote
origin
$ git remote add pb <https://github.com/paulboone/ticgit>

## Получение изменений

Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у другого, но нет у вас, вы можете выполнить команду git fetch pb
git fetch [remote-name]
$ git fetch pb

Команда git fetch связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После выполнения этой команды у вас появятся ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.
git fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы

git pull
Git pull извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете

## Отправка изменений

Если вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Для этого используйте простую команду:
git push <remote-name> <branch-name>

## Просмотр удалённого репозитория

Команда $ git remote show origin:

- выдаёт URL удалённого репозитория
- выдаёт информацию об отслеживаемых ветках
-сообщает, что если, находясь на ветке master, вы выполните git pull, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных
- выдаёт список всех полученных ею ссылок
- показывает, какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении git pushпоказывает, каких веток с удалённого сервера у вас ещё нет
- показывает, какие ветки всё ещё есть, но уже удалены на сервере
-для нескольких веток показывает, какие удалённые ветки будут в них влиты при выполнении git pull

## Удаление

Команда git remote rm

## Просмотр списка тегов

Просмотреть список имеющихся тегов в Git очень просто с помощью команды git tag (параметры -l и --list опциональны)
$ git tag
v0.1
v1.3

$ git tag -l 'v1.8.5*' (-l это сокращение к --list)
v1.8.5
v1.8.5-rc0
v1.8.5-rc1
v1.8.5-rc2
v1.8.5-rc3
v1.8.5.1
v1.8.5.2

## Аннотированные теги

Создание аннотированной метки в Git выполняется легко. Самый простой способ — указать -a при выполнении команды tag:
$ git tag -a v0.0 -m 'init version'
$ git tag
v0.0
$ git show v0.0
tag v0.0
Tagger: andrey.borue <andrey.borue@gml.com>

## Легковесные теги

Для создания легковесной метки не передавайте опций -a, -s и -m,
укажите только название:
$ git tag v0.2
$ git tag
v0.0
v0.2
$ git show v0.2
commit 46906d6836ea1f649788579e1c7f16afecc38...

## Обмен тегами

После создания теги нужно отправлять на удалённый сервер. Процесс аналогичен отправке веток — достаточно выполнить команду
git push origin <tagname>:
$ git push origin v0.0
...
- [new tag] v0.0 -> v0.0

Если у вас много тегов и вам хотелось бы отправить все за один раз,
то можно использовать опцию --tags для команды git push:
$ git push <remote> --tags

# Удаление локального тега

Для удаления тега в локальном репозитории достаточно выполнить команду:
$ git tag -d <tagname>
Обратите внимание, что при удалении тега не происходит его удаления с сервера

Удаление тега из удалённого репозитория
Распространены два способа удаления тега из удалённого репозитория. Первый способ — выполнить команду:
$ git push origin :refs/tags/v0.0
...

- [deleted] v0.0

Второй способ — удалить тег из удалённого репозитория — более
интуитивный:
$ git push origin --delete <tagname>

## Переход на тег

Если вы хотите получить версии файлов, на которые указывает тег, то вы можете сделать git checkout для тега. Однако это переведёт репозиторий в состояние detached HEAD, которое имеет ряд неприятных побочных эффектов
git checkout v0.0

## Создание ветки от тега

Если в состоянии detached HEAD внести изменения и сделать коммит, то тег не изменится. При этом новый коммит не будет относиться ни к какой из веток, а доступ к нему можно будет получить только по его хешу. Поэтому если вам нужно внести изменения, исправить ошибку в одной из старых версий, вам следует создать ветку:
$ git checkout -b version0 v0.0
Switched to a new branch 'version0'
или
$ git switch -c version0 v0.0
Switched to a new branch 'version0

## Псевдонимы команд

Если вы не хотите печатать каждую команду для Git целиком, вы можете настроить псевдонимы (alias) для любой команды с помощью git config. Вот несколько примеров псевдонимов, которые вы, возможно, захотите задать:
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status
$ git config --global alias.last 'log -1 HEAD'
$ git config --global alias.visual "!gitk"

## Создание ветки

Создание ветки — это создание нового указателя для дальнейшего перемещения. Создадим новую ветку с именем testing. Вы можете это сделать командой:
$ git branch testing
В результате создаётся новый указатель на текущий коммит
